<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Lamborghini Hold ‚Äî Verd@Net</title>

  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;900&display=swap" rel="stylesheet">

  <style>
    :root { color-scheme: dark; }
    body{ font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, sans-serif; }

    /* Fondo */
    .bg{
      position:fixed; inset:0; z-index:-2;
      background-size:cover; background-position:center;
      filter:saturate(1.08) contrast(1.05);
    }
    .bg::after{
      content:""; position:absolute; inset:0;
      background: radial-gradient(circle at 20% 20%, rgba(255,255,255,.08), transparent 40%),
                  radial-gradient(circle at 80% 60%, rgba(236,72,153,.10), transparent 45%),
                  linear-gradient(180deg, rgba(0,0,0,.65), rgba(0,0,0,.85));
    }

    /* Panel glass */
    .glass{
      background: rgba(255,255,255,.06);
      border: 1px solid rgba(255,255,255,.12);
      backdrop-filter: blur(10px);
    }

    /* Lambo flotando */
    #arena{ position: relative; width: 100%; height: calc(100vh - 132px); overflow:hidden; }
    #lambo{
      position:absolute;
      width: 140px;
      height: 90px;
      background: center/contain no-repeat;
      filter: drop-shadow(0 16px 24px rgba(0,0,0,.55));
      transform: translate(-50%,-50%) rotate(-6deg);
      transition: transform 140ms ease;
      user-select:none;

      /* IMPORTANT√çSIMO: si no, en m√≥vil no detecta bien */
      touch-action: none;
      -webkit-touch-callout: none;
    }
    #lambo:active{ transform: translate(-50%,-50%) rotate(4deg) scale(1.03); }

    /* HUD */
    .pill{
      background: rgba(255,255,255,.08);
      border: 1px solid rgba(255,255,255,.12);
      border-radius: 999px;
      padding: 6px 10px;
      font-size: 12px;
      color: rgba(255,255,255,.85);
    }
    .titleGlow{
      text-shadow: 0 10px 26px rgba(236,72,153,.25), 0 0 40px rgba(124,58,237,.25);
    }

    /* Barra tiempo */
    .bar{ height: 8px; border-radius: 999px; background: rgba(255,255,255,.12); overflow:hidden; }
    .bar i{ display:block; height:100%; width:0%; background: linear-gradient(90deg, #22d3ee, #a78bfa, #ec4899); }

    /* Overlay countdown */
    #overlay{
      position: fixed; inset:0; z-index:50;
      display:none; align-items:center; justify-content:center;
      background: radial-gradient(circle at 50% 35%, rgba(255,255,255,.16), rgba(0,0,0,.85));
      backdrop-filter: blur(8px);
    }
    .countNum{
      font-weight: 900;
      font-size: clamp(72px, 18vw, 180px);
      letter-spacing:-.06em;
      color: rgba(255,255,255,.95);
      text-shadow: 0 16px 40px rgba(0,0,0,.55);
      transform: translateY(-8px);
    }
    .subGlow{
      color: rgba(255,255,255,.8);
      text-shadow: 0 10px 30px rgba(0,0,0,.55);
    }

    /* Tabla top */
    .row{
      display:flex; align-items:center; justify-content:space-between;
      gap: 10px;
      padding: 8px 10px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.04);
    }
    .dot{
      width:10px; height:10px; border-radius:999px;
      background: rgba(255,255,255,.25);
      box-shadow: 0 0 0 1px rgba(255,255,255,.12);
    }
    .dot.on{ background: #22c55e; box-shadow: 0 0 0 1px rgba(34,197,94,.25), 0 0 18px rgba(34,197,94,.25); }
    .dot.dead{ background: #f43f5e; box-shadow: 0 0 0 1px rgba(244,63,94,.25), 0 0 18px rgba(244,63,94,.22); }
  </style>
</head>

<body class="min-h-screen text-white bg-neutral-950">
  <!-- === CAMBIA AQU√ç LOS ASSETS ===
    Fondo:  assets/backgrounds/lambo_bg.jpg
    Lambo:  assets/lambo/lambo.png
  -->
  <div id="bg" class="bg"></div>

  <div class="max-w-6xl mx-auto px-4 pt-4 pb-2">
    <header class="glass rounded-2xl p-4 flex flex-col md:flex-row md:items-center md:justify-between gap-3">
      <div class="flex items-center gap-3">
        <div class="w-10 h-10 rounded-2xl bg-white/10 border border-white/15 grid place-items-center font-black">VN</div>
        <div>
          <div class="text-xl md:text-2xl font-extrabold titleGlow">Lamborghini Hold</div>
          <div id="meLine" class="text-sm text-white/70">Sin sesi√≥n‚Ä¶</div>
        </div>
      </div>

      <div class="flex flex-wrap items-center gap-2 justify-start md:justify-end">
        <span id="roomPill" class="pill">Sala: sala-unica</span>
        <span id="modePill" class="pill">Modo: Normal</span>
        <span id="roundPill" class="pill">Ronda: 0</span>
        <span id="timerPill" class="pill">Tiempo: ‚Äî</span>
        <span id="goalPill" class="pill">Meta: 5 pts</span>
      </div>
    </header>

    <!-- Admin bar -->
    <section id="adminBar" class="hidden glass rounded-2xl p-3 mt-3 flex flex-wrap gap-2 items-center">
      <span class="text-xs px-2 py-1 rounded bg-amber-400/15 border border-amber-300/25">Admin</span>

      <button id="btnStart2" class="px-3 py-2 rounded-xl bg-emerald-500/80 hover:bg-emerald-500 disabled:opacity-40 disabled:hover:bg-emerald-500">
        Empezar (min 2)
      </button>

      <button id="btnStop" class="px-3 py-2 rounded-xl bg-rose-600/80 hover:bg-rose-600">
        Detener y volver lobby
      </button>

      <button id="btnMode" class="px-3 py-2 rounded-xl bg-white/10 hover:bg-white/20">
        Cambiar modo (Normal/Moving)
      </button>

      <button id="btnResetScores" class="ml-auto px-3 py-2 rounded-xl bg-white/10 hover:bg-white/20">
        Reset puntos
      </button>
    </section>

    <!-- Lobby + Leaderboard -->
    <div class="grid grid-cols-1 lg:grid-cols-[360px_1fr] gap-3 mt-3">
      <aside class="glass rounded-2xl p-4">
        <div class="flex items-center justify-between mb-2">
          <div class="font-semibold">Jugadores</div>
          <div id="lobbyCount" class="text-sm text-white/70">0 online</div>
        </div>

        <div id="playersList" class="space-y-2"></div>

        <div class="mt-4">
          <div class="text-xs text-white/60 mb-1">Tiempo de ronda</div>
          <div class="bar"><i id="timeBar"></i></div>
          <div class="mt-2 text-xs text-white/60">
            Regla: si termina el <b>3..2..1</b> y NO est√°s agarrando el lambo ‚Üí <b>KO</b>.
          </div>
        </div>

        <div id="hint" class="mt-4 text-xs text-white/60">
          Tip: Mant√©n pulsado el lambo (rat√≥n o dedo). Si lo sueltas, pierdes la ronda.
        </div>
      </aside>

      <!-- Arena -->
      <main class="glass rounded-2xl p-3 relative">
        <div class="flex items-center justify-between px-2 pb-2">
          <div id="statusLine" class="text-sm text-white/80">Estado: lobby</div>
          <div class="text-xs text-white/60">Aguanta. No parpadees. üèéÔ∏è</div>
        </div>

        <div id="arena" class="rounded-2xl border border-white/10 bg-white/5">
          <div id="lambo" aria-label="Lambo"></div>
        </div>
      </main>
    </div>
  </div>

  <!-- Countdown overlay -->
  <div id="overlay">
    <div class="text-center">
      <div id="countNum" class="countNum">3</div>
      <div id="countSub" class="subGlow text-base md:text-lg -mt-4">¬°Ag√°rralo YA!</div>
    </div>
  </div>

<script type="module">
  // =========================
  // Firebase SDKs
  // =========================
  import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.4/firebase-app.js";
  import {
    getAuth, onAuthStateChanged,
    GoogleAuthProvider, signInWithPopup,
    signInAnonymously
  } from "https://www.gstatic.com/firebasejs/10.12.4/firebase-auth.js";
  import {
    getFirestore,
    doc, getDoc, setDoc, updateDoc, onSnapshot,
    collection, getDocs, deleteDoc, serverTimestamp
  } from "https://www.gstatic.com/firebasejs/10.12.4/firebase-firestore.js";

  // =========================
  // Config
  // =========================
  const firebaseConfig = {
    apiKey: "AIzaSyCkNI9EEw_4Rf8f4IqygydRTbHSHBAYnKs",
    authDomain: "klex-28ea5.firebaseapp.com",
    databaseURL: "https://klex-28ea5-default-rtdb.europe-west1.firebasedatabase.app",
    projectId: "klex-28ea5",
    storageBucket: "klex-28ea5.appspot.com",
    messagingSenderId: "794750673743",
    appId: "1:794750673743:web:8b38291a417089e643db3a",
    measurementId: "G-DQ6E8NBVGR"
  };

  // Admin (tu email real)
  const ADMIN_EMAIL = "hodelyproductions@gmail.com";

  // Sala
  const ROOM_ID = "sala-unica";

  // Assets (pon tus rutas aqu√≠)
  const BACKGROUND_URL = "assets/backgrounds/lambo_bg.jpg";
  const LAMBO_IMG      = "assets/lambo/lambo.png";

  // Gameplay
  const MIN_PLAYERS = 2;
  const ROUND_SECONDS = 35;        // duraci√≥n base
  const COUNTDOWN_SECONDS = 3;     // 3..2..1
  const SPEED_AFTER = 15;          // a partir de 15s, acelera (modo moving)
  const HEARTBEAT_MS = 5000;
  const FAST_STATE_MS = 260;       // holding updates
  const LOBBY_TIMEOUT_MS = 20000;  // online si lastSeen < 20s
  const ADMIN_TICK_MS = 200;       // movimiento (admin)

  const GOAL_POINTS = 5;

  // =========================
  // App init
  // =========================
  const app = initializeApp(firebaseConfig);
  const auth = getAuth(app);
  const db   = getFirestore(app);

  const roomRef = doc(db, "games", "lambo", "rooms", ROOM_ID);
  const playersCol = collection(roomRef, "players");

  // =========================
  // DOM
  // =========================
  const $ = (s)=>document.querySelector(s);
  const bg = $("#bg");
  const meLine = $("#meLine");
  const adminBar = $("#adminBar");
  const btnStart2 = $("#btnStart2");
  const btnStop = $("#btnStop");
  const btnMode = $("#btnMode");
  const btnResetScores = $("#btnResetScores");

  const roomPill = $("#roomPill");
  const modePill = $("#modePill");
  const roundPill = $("#roundPill");
  const timerPill = $("#timerPill");
  const goalPill = $("#goalPill");

  const lobbyCount = $("#lobbyCount");
  const playersList = $("#playersList");
  const statusLine = $("#statusLine");

  const arena = $("#arena");
  const lambo = $("#lambo");
  const timeBar = $("#timeBar");

  const overlay = $("#overlay");
  const countNum = $("#countNum");
  const countSub = $("#countSub");

  // Assets apply
  bg.style.backgroundImage = `url('${BACKGROUND_URL}')`;
  lambo.style.backgroundImage = `url('${LAMBO_IMG}')`;

  roomPill.textContent = `Sala: ${ROOM_ID}`;
  goalPill.textContent = `Meta: ${GOAL_POINTS} pts`;

  // =========================
  // State
  // =========================
  let me = null;
  let isAdmin = false;
  let room = null;
  let cachedPlayers = {};
  let activePlayers = [];

  // holding local (para no depender del lag)
  let holding = false;

  // timers
  let tFast = null;
  let tAdminTick = null;
  let tHeartbeat = null;

  // =========================
  // Auth helpers
  // =========================
  const provider = new GoogleAuthProvider();

  // Si vienes desde tu chat, ya estar√°s logeado.
  // Si NO, entramos an√≥nimo para que el juego funcione igual.
  async function ensureSignedIn(){
    if(auth.currentUser) return;
    try { await signInAnonymously(auth); }
    catch { await signInWithPopup(auth, provider); }
  }
  ensureSignedIn();

  onAuthStateChanged(auth, async (user)=>{
    if(!user){
      meLine.textContent = "Sin sesi√≥n‚Ä¶";
      return;
    }

    const email = user.email || "";
    const name =
      user.displayName ||
      (email ? email.split("@")[0] : "Anon") ||
      "Jugador";

    me = { uid:user.uid, email, name, anon: user.isAnonymous };
    isAdmin = (!!email && email === ADMIN_EMAIL);

    meLine.textContent = `T√∫: ${me.name}${me.anon ? " (anon)" : ""}${isAdmin ? " (admin)" : ""}`;
    adminBar.classList.toggle("hidden", !isAdmin);

    await ensureRoomExists();
    await joinPresence();
    attachListeners();
    wireControls();
  });

  // =========================
  // Room bootstrap
  // =========================
  async function ensureRoomExists(){
    const snap = await getDoc(roomRef);
    if(!snap.exists()){
      if(!isAdmin){
        // Si no existe y no eres admin, no la creamos.
        // (Puedes crearla entrando como admin una vez.)
        return;
      }
      await setDoc(roomRef, {
        status: "lobby",          // lobby | countdown | playing | end
        mode: "still",            // still | moving
        round: 0,
        goalPoints: GOAL_POINTS,
        countdownAt: null,
        startedAt: null,
        roundEndsAt: null,
        winnerUid: null,
        winnerName: null,

        // pos y velocidad del lambo (admin)
        lamboX: 50,
        lamboY: 55,
        lamboVX: 0.22,
        lamboVY: 0.18,

        adminUid: me.uid,
        updatedAt: serverTimestamp(),
        createdAt: serverTimestamp()
      });
    } else if(isAdmin){
      const r = snap.data();
      if(!r.adminUid || r.adminUid !== me.uid){
        await updateDoc(roomRef, { adminUid: me.uid, updatedAt: serverTimestamp() });
      }
    }
  }

  // =========================
  // Presence
  // =========================
  async function joinPresence(){
    const meRef = doc(playersCol, me.uid);

    await setDoc(meRef, {
      uid: me.uid,
      name: me.name,
      email: me.email || null,
      bot: false,

      score: 0,
      alive: true,
      holding: false,

      lastSeen: Date.now()
    }, { merge: true });

    clearInterval(tHeartbeat);
    tHeartbeat = setInterval(async ()=>{
      try{
        await updateDoc(meRef, { lastSeen: Date.now() });
      }catch{}
    }, HEARTBEAT_MS);

    // Fast updates: holding + lastSeen (cuando hay partida)
    clearInterval(tFast);
    tFast = setInterval(async ()=>{
      if(!room) return;
      if(!me) return;
      const status = room.status;
      const shouldSend = (status === "countdown" || status === "playing");
      if(!shouldSend) return;

      try{
        await updateDoc(meRef, { holding: !!holding, lastSeen: Date.now() });
      }catch{}
    }, FAST_STATE_MS);
  }

  // =========================
  // Listeners
  // =========================
  function attachListeners(){
    onSnapshot(roomRef, (snap)=>{
      if(!snap.exists()) return;
      room = snap.data();
      renderRoom(room);
    });

    onSnapshot(playersCol, (qs)=>{
      const now = Date.now();
      cachedPlayers = {};
      const act = [];
      qs.forEach(d=>{
        const p = d.data();
        cachedPlayers[p.uid] = p;
        if(now - (p.lastSeen||0) <= LOBBY_TIMEOUT_MS) act.push(p);
      });
      activePlayers = act.sort((a,b)=> (b.score||0) - (a.score||0));
      renderPlayers(activePlayers);
      if(isAdmin) updateAdminButtons();
    });
  }

  // =========================
  // UI render
  // =========================
  function renderPlayers(list){
    lobbyCount.textContent = `${list.length} online`;
    playersList.innerHTML = "";

    list.forEach(p=>{
      const row = document.createElement("div");
      row.className = "row";

      const dot = document.createElement("div");
      dot.className = "dot " + (p.alive ? "on" : "dead");

      const left = document.createElement("div");
      left.className = "flex items-center gap-2 min-w-0";
      const name = document.createElement("div");
      name.className = "font-semibold truncate";
      name.textContent = p.name || "Jugador";

      const tag = document.createElement("div");
      tag.className = "text-xs text-white/60";
      tag.textContent =
        (p.uid === me?.uid ? "t√∫" : "") +
        (p.bot ? (p.uid === me?.uid ? " ¬∑ bot" : "bot") : "");

      left.append(dot, (()=>{
        const wrap = document.createElement("div");
        wrap.className="min-w-0";
        wrap.append(name, tag);
        return wrap;
      })());

      const right = document.createElement("div");
      right.className = "flex items-center gap-2";
      const score = document.createElement("div");
      score.className = "pill";
      score.textContent = `${p.score||0} pts`;

      const hold = document.createElement("div");
      hold.className = "text-xs text-white/60";
      hold.textContent = (room && (room.status==="countdown" || room.status==="playing"))
        ? (p.holding ? "AGARRA" : "SUELTO")
        : "";

      right.append(hold, score);
      row.append(left, right);
      playersList.appendChild(row);
    });
  }

  function renderRoom(r){
    const modeLabel = r.mode === "moving" ? "Moving" : "Normal";
    modePill.textContent = `Modo: ${modeLabel}`;
    roundPill.textContent = `Ronda: ${r.round || 0}`;
    goalPill.textContent = `Meta: ${(r.goalPoints||GOAL_POINTS)} pts`;

    statusLine.textContent = `Estado: ${r.status}`;

    // Coloca lambo por % en el arena
    placeLambo(r.lamboX ?? 50, r.lamboY ?? 55);

    // overlay countdown
    if(r.status === "countdown" && r.countdownAt){
      overlay.style.display = "flex";
      const ms = r.countdownAt - Date.now();
      const s = Math.max(0, Math.ceil(ms / 1000));
      countNum.textContent = String(Math.min(COUNTDOWN_SECONDS, s));
      countSub.textContent = "¬°Ag√°rralo YA! (puedes mantener durante el 3..2..1)";
    } else {
      overlay.style.display = "none";
    }

    // timer
    if(r.status === "playing" && r.roundEndsAt && r.startedAt){
      const leftMs = r.roundEndsAt - Date.now();
      const left = Math.max(0, Math.ceil(leftMs/1000));
      timerPill.textContent = `Tiempo: ${left}s`;

      const total = ROUND_SECONDS;
      const prog = Math.min(1, Math.max(0, (total - left) / total));
      timeBar.style.width = `${prog*100}%`;
    } else {
      timerPill.textContent = "Tiempo: ‚Äî";
      timeBar.style.width = "0%";
    }
  }

  function placeLambo(xPct, yPct){
    const rect = arena.getBoundingClientRect();
    // convert % to px
    const x = rect.width  * (xPct/100);
    const y = rect.height * (yPct/100);
    lambo.style.left = `${x}px`;
    lambo.style.top  = `${y}px`;
  }

  function updateAdminButtons(){
    const onlineCount = activePlayers.length;
    const canStart = onlineCount >= MIN_PLAYERS && (room?.status === "lobby" || room?.status === "end");
    btnStart2.disabled = !canStart;
  }

  // =========================
  // Controls (HOLD FIX)
  // =========================
  function wireControls(){
    // Pointer hold with capture (fix total)
    const down = (e)=>{
      // Permitimos agarrar tanto en countdown como en playing
      if(!room) return;
      if(room.status !== "countdown" && room.status !== "playing") return;

      holding = true;

      // Captura: aunque el lambo se mueva o el dedo se salga un poco, seguimos ‚Äúholding‚Äù
      try{ e.target.setPointerCapture?.(e.pointerId); }catch{}

      e.preventDefault?.();
    };
    const up = ()=>{
      if(!room) return;
      // Si sueltas en countdown o playing, te contar√° como suelto
      if(room.status !== "countdown" && room.status !== "playing") return;
      holding = false;
    };

    lambo.addEventListener("pointerdown", down);
    window.addEventListener("pointerup", up);
    window.addEventListener("pointercancel", ()=>{ holding=false; });
    window.addEventListener("blur", ()=>{ holding=false; });

    // Reposicionar lambo al resize
    window.addEventListener("resize", ()=>{
      if(!room) return;
      placeLambo(room.lamboX ?? 50, room.lamboY ?? 55);
    });

    // Admin controls
    btnMode.addEventListener("click", async ()=>{
      if(!isAdmin || !room) return;
      const next = (room.mode === "moving") ? "still" : "moving";
      await updateDoc(roomRef, { mode: next, updatedAt: serverTimestamp() });
    });

    btnStart2.addEventListener("click", async ()=>{
      if(!isAdmin || !room) return;
      // recalcula online
      const now = Date.now();
      const qs = await getDocs(playersCol);
      const online = [];
      qs.forEach(d=>{
        const p=d.data();
        if(now-(p.lastSeen||0) <= LOBBY_TIMEOUT_MS && !p.bot) online.push(p);
      });
      if(online.length < MIN_PLAYERS){
        alert(`Necesitas m√≠nimo ${MIN_PLAYERS} jugadores online.`);
        return;
      }
      await startRound();
    });

    btnStop.addEventListener("click", async ()=>{
      if(!isAdmin || !room) return;
      await stopToLobby();
    });

    btnResetScores.addEventListener("click", async ()=>{
      if(!isAdmin) return;
      const qs = await getDocs(playersCol);
      for(const d of qs.docs){
        await updateDoc(d.ref, { score:0, alive:true, holding:false });
      }
      await updateDoc(roomRef, { status:"lobby", round:0, winnerUid:null, winnerName:null, updatedAt: serverTimestamp() });
    });
  }

  // =========================
  // Admin: round flow
  // =========================
  async function stopToLobby(){
    // Para y vuelve a lobby
    await updateDoc(roomRef, {
      status: "lobby",
      countdownAt: null,
      startedAt: null,
      roundEndsAt: null,
      winnerUid: null,
      winnerName: null,
      updatedAt: serverTimestamp()
    });

    // resetea estado jugadores (no puntos)
    const qs = await getDocs(playersCol);
    for(const d of qs.docs){
      await updateDoc(d.ref, { alive:true, holding:false });
    }
    stopAdminTick();
  }

  async function startRound(){
    // reset alive/holding
    const qs = await getDocs(playersCol);
    for(const d of qs.docs){
      const p = d.data();
      // Solo los online cuentan para ronda, pero dejamos doc igualmente
      await updateDoc(d.ref, { alive:true, holding:false });
    }

    // randomize lambo pos
    const lx = 15 + Math.random()*70;
    const ly = 20 + Math.random()*60;

    const countdownAt = Date.now() + COUNTDOWN_SECONDS*1000;
    const startedAt = countdownAt;
    const roundEndsAt = startedAt + ROUND_SECONDS*1000;

    await updateDoc(roomRef, {
      status: "countdown",
      countdownAt,
      startedAt: null,
      roundEndsAt: null,
      winnerUid: null,
      winnerName: null,

      lamboX: lx,
      lamboY: ly,
      lamboVX: 0.22 + Math.random()*0.12,
      lamboVY: 0.18 + Math.random()*0.12,
      updatedAt: serverTimestamp()
    });

    // En el momento exacto que acaba el countdown: arrancamos playing y hacemos KO a los que no agarran
    setTimeout(async ()=>{
      // start playing
      const rs = await getDoc(roomRef);
      if(!rs.exists()) return;
      const r = rs.data();
      if(r.status !== "countdown") return; // alguien lo detuvo

      await updateDoc(roomRef, {
        status: "playing",
        countdownAt: null,
        startedAt,
        roundEndsAt,
        round: (r.round||0) + 1,
        updatedAt: serverTimestamp()
      });

      // KO si NO est√° holding justo al empezar (con gracia)
      setTimeout(async ()=>{
        try{
          const now = Date.now();
          const qs2 = await getDocs(playersCol);
          for(const d of qs2.docs){
            const p = d.data();
            if(now-(p.lastSeen||0) > LOBBY_TIMEOUT_MS) continue; // fuera
            // Para ti, usamos estado local (cero lag)
            const isHolding = (p.uid === me?.uid) ? holding : !!p.holding;
            if(!isHolding){
              await updateDoc(d.ref, { alive:false, holding:false });
            }
          }
          await maybeResolveRound(); // por si alguien cae instant
          startAdminTick();
        }catch{}
      }, 250);
    }, COUNTDOWN_SECONDS*1000);
  }

  function startAdminTick(){
    if(!isAdmin) return;
    stopAdminTick();

    tAdminTick = setInterval(async ()=>{
      try{
        const rs = await getDoc(roomRef);
        if(!rs.exists()) return;
        const r = rs.data();
        if(r.status !== "playing"){
          stopAdminTick();
          return;
        }

        // 1) movimiento si modo moving
        if(r.mode === "moving"){
          const rect = arena.getBoundingClientRect();
          const w = rect.width, h = rect.height;

          // convert current % to px
          let x = (r.lamboX ?? 50) / 100 * w;
          let y = (r.lamboY ?? 55) / 100 * h;
          let vx = (r.lamboVX ?? 0.22);
          let vy = (r.lamboVY ?? 0.18);

          // Acelera a partir de 15s (m√°s tiempo = m√°s r√°pido)
          const elapsed = Math.max(0, Math.floor((Date.now() - (r.startedAt||Date.now()))/1000));
          const boost = elapsed > SPEED_AFTER ? (elapsed - SPEED_AFTER) * 0.012 : 0; // aceleraci√≥n progresiva
          const speedMul = 1 + boost;

          const pxStep = 6.0 * speedMul;
          x += vx * pxStep;
          y += vy * pxStep;

          // l√≠mites (dejamos margen del tama√±o del lambo)
          const marginX = 70, marginY = 55;
          if(x < marginX){ x = marginX; vx = Math.abs(vx); }
          if(x > w - marginX){ x = w - marginX; vx = -Math.abs(vx); }
          if(y < marginY){ y = marginY; vy = Math.abs(vy); }
          if(y > h - marginY){ y = h - marginY; vy = -Math.abs(vy); }

          const xPct = (x / w) * 100;
          const yPct = (y / h) * 100;

          await updateDoc(roomRef, {
            lamboX: xPct,
            lamboY: yPct,
            lamboVX: vx,
            lamboVY: vy,
            updatedAt: serverTimestamp()
          });
        }

        // 2) KO a los que sueltan (en servidor)
        //    (si alguien suelta y el doc lo refleja, muere)
        const qs = await getDocs(playersCol);
        const now = Date.now();
        for(const d of qs.docs){
          const p = d.data();
          if(now-(p.lastSeen||0) > LOBBY_TIMEOUT_MS) continue;
          if(!p.alive) continue;

          // si NO holding ‚Üí KO
          // Para ti, usamos estado local holding (m√°s preciso)
          const isHolding = (p.uid === me?.uid) ? holding : !!p.holding;
          if(!isHolding){
            await updateDoc(d.ref, { alive:false, holding:false });
          }
        }

        // 3) resolver por tiempo / √∫ltimo vivo
        await maybeResolveRound();

      } catch {}
    }, ADMIN_TICK_MS);
  }

  function stopAdminTick(){
    clearInterval(tAdminTick);
    tAdminTick = null;
  }

  async function maybeResolveRound(){
    const rs = await getDoc(roomRef);
    if(!rs.exists()) return;
    const r = rs.data();
    if(r.status !== "playing") return;

    // ¬øtiempo acabado?
    const timeUp = r.roundEndsAt && Date.now() >= r.roundEndsAt;

    const qs = await getDocs(playersCol);
    const now = Date.now();

    const aliveOnline = [];
    qs.forEach(d=>{
      const p=d.data();
      if(now-(p.lastSeen||0) > LOBBY_TIMEOUT_MS) return;
      if(p.alive) aliveOnline.push(p);
    });

    if(aliveOnline.length <= 1 || timeUp){
      // winner = √∫nico vivo, o si timeUp: preferimos alguien holding (si queda alguno)
      let winner = aliveOnline[0] || null;

      if(timeUp && aliveOnline.length > 0){
        const holders = aliveOnline.filter(p=> !!p.holding);
        if(holders.length) winner = holders[Math.floor(Math.random()*holders.length)];
        else winner = aliveOnline[Math.floor(Math.random()*aliveOnline.length)];
      }

      // Award
      if(winner){
        await updateDoc(doc(playersCol, winner.uid), { score: (winner.score||0) + 1 });
      }

      // ¬øalguien llega a meta?
      const qs2 = await getDocs(playersCol);
      let champ = null;
      qs2.forEach(d=>{
        const p=d.data();
        if((p.score||0) >= (r.goalPoints||GOAL_POINTS)) champ = p;
      });

      if(champ){
        await updateDoc(roomRef, {
          status:"end",
          winnerUid: champ.uid,
          winnerName: champ.name,
          countdownAt:null,
          startedAt:null,
          roundEndsAt:null,
          updatedAt: serverTimestamp()
        });
        stopAdminTick();
        return;
      }

      // Si no hay campe√≥n, volvemos a lobby ‚Äúentre rondas‚Äù
      await updateDoc(roomRef, {
        status:"lobby",
        winnerUid: winner?.uid || null,
        winnerName: winner?.name || null,
        countdownAt:null,
        startedAt:null,
        roundEndsAt:null,
        updatedAt: serverTimestamp()
      });
      stopAdminTick();

      // Reset alive/holding para siguiente ronda (puntos se quedan)
      const qs3 = await getDocs(playersCol);
      for(const d of qs3.docs){
        await updateDoc(d.ref, { alive:true, holding:false });
      }
    }
  }
</script>
</body>
</html>
